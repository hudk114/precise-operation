## 需求

  提供精确的四舍五入运算

  - 输入：数字或标准数字格式的字符串
      - 如果输入错误的内容或参数错误，抛出异常
  - 输出：以字符串形式输出计算结果
      - 计算结果精度可配置
      - 默认保存到21位（precise与parseInt方式保留到16位）

## 参数检查与异常处理
  
  1. 输入参数不足
      - 抛出异常 `输入参数错误`
  1. 输入非标准数字
      - 抛出异常 `输入参数错误`
  1. 精度丢失（由于超出安全范围）
      - 控制台打印告警信息（默认开启） `超出安全范围，精度可能丢失`
      - 抛出异常（默认关闭） `超出安全范围，精度可能丢失`

## 代码结构与设计

  1. 代码结构
      ```
      project
      │   README.md
      │   file001.txt    
      │
      └───src
      │   │   index.js            项目入口
      │   │   config.js           配置项
      │   │   error.js            异常包装
      │   │   utils.js      
      │   │   
      │   └───calc                四则运算的核心逻辑
      │   │   │   index.js
      │   │   │   precision-calculation.js
      │   │   │   parse-to-int-calculation.js
      │   │   │   custom-calculation.js
      │   │
      │   └───pre                 预处理，负责在主逻辑开始前进行数据处理
      │       │   pre-check.js
      │       │   pre-calc.js
      │       │   pre-process.js
      │
      └───test                    单元测试
      │    │   add.test.js
      │    │   minus.test.js
      │    │   multi.test.js
      │    │   division.test.js
      │    │   pre.test.js
      │
      └───example                 例子，dev开发调试
      ```

  1. 设计
      
      - 实现了三种核心算法，参考策略模式进行调用
      - 对于边界条件和参数的判断提供统一处理方法
        - 该需求中，判断过程放在最顶端的入口处，内部的处理逻辑的重点放在核心逻辑实现上，只进行简单的参数判断

## 算法实现

  问题的原因在于小数的二进制表示是无法精确表达的，因此二进制的计算和转化为十进制的过程中会丢失精度，造成显示结果的不精确

  1. precision-calculation

      通过toPercision对数据进行求整，因为js对小数的取整是到16位，因此我默认采用收敛到了15位小数。但这种解法有精确度的问题。
      
  1. parse-to-int-calculation

      相对于小数，整数的二进制表示和计算不会丢失精度，因此我的第二种解法是将小数转化为整数计算，算完后再转化为小数。但是这种计算方式容易超出js的安全数据范围，也会丢失精确度。

  1. custom-calculation

      在最后一种方案中我采用了将数字展开为单数字的数组，并通过模拟手工计算的方式实现四则运算并返回，这种方式可以最大范围的保证精度，并且可以支持无限精度的计算。

## 参考

  在开始的设计过程中我参考了一些业内的解决方案和比较出名的库，包括number-precesion和big.js，写完之后我也和几个库对照着看了一下并进行了一些修改，其中最后一种解决方案的数据类型就是参考big.js和big-number.js设计的，但是具体的运算逻辑我觉得他们写得相对晦涩，也有一部分是不需要在这个场景中使用的，因此是自己重新设计和编写的。
  
  对于三种解决方案的具体优缺点，后续的一些改进点以及我所认为的对应场景，写在具体的对应文件上